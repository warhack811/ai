from __future__ import annotations

from typing import Optional

from core.logger import get_logger
from router.groq_decider import (
    run_decider,
    run_decider_stub,                # â† eklenecek
    decide_memory_storage,
    summarize_conversation_for_rag,   # ğŸ”¥ yeni
)
from router.search_router import handle_internet_action
from auth.user_manager import get_user_by_username
from ollama.gemma_handler import run_local_chat
from image.image_manager import request_image_generation, generate_image_sync
from router.groq_answerer import generate_answer

# HafÄ±za ve RAG
from core.conversation_store import get_recent_context
from core.memory_store import search_memories, add_memory
from core.rag_store import search_documents

logger = get_logger(__name__)

async def _build_image_prompt_with_bela(username: str, base_prompt: str) -> str:
    """
    KullanÄ±cÄ±nÄ±n (genelde TÃ¼rkÃ§e) gÃ¶rsel isteÄŸini,
    Bela (Gemma) kullanarak detaylÄ± ve Ä°ngilizce bir image prompt'a Ã§evirir.
    Beklenen format: 'prompt: <ingilizce prompt>'
    """
    instruction = (
        "AÅŸaÄŸÄ±da bir kullanÄ±cÄ±nÄ±n gÃ¶rsel isteÄŸi var.\n"
        "GÃ¶revin:\n"
        "- Bu isteÄŸi bir text-to-image (metinden gÃ¶rsele) model iÃ§in Ã§ok detaylÄ±, tek satÄ±rlÄ±k bir prompt'a dÃ¶nÃ¼ÅŸtÃ¼r.\n"
        "- Son prompt TAMAMEN Ä°ngilizce olmalÄ±.\n"
        "- Ortam, atmosfer, Ä±ÅŸÄ±k, kamera aÃ§Ä±sÄ±, kompozisyon, stil, kalite, Ã§Ã¶zÃ¼nÃ¼rlÃ¼k gibi detaylar ekle.\n"
        "- Cevap formatÄ±n ÅUNA UYMALI:\n"
        "prompt: <sadece Ä°ngilizce prompt>\n"
        "- 'prompt:' kelimesi dÄ±ÅŸÄ±nda aÃ§Ä±klama, Ã§eviri notu, fazladan cÃ¼mle yazma.\n\n"
        f"KullanÄ±cÄ± isteÄŸi: {base_prompt}"
    )

    raw = await run_local_chat(
        username,
        instruction,
        analysis={"task": "image_prompt"},
    )

    if not raw:
        # Her ihtimale karÅŸÄ± fallback
        return base_prompt

    lower = raw.lower()
    idx = lower.find("prompt:")
    if idx == -1:
        # Model formatÄ± bozarsa, gelen cevabÄ± direkt kullan
        return raw.strip()

    result = raw[idx + len("prompt:"):].strip()

    # Ã‡evresindeki tÄ±rnak / backtick'leri temizle
    if (result.startswith('"') and result.endswith('"')) or (
        result.startswith("'") and result.endswith("'")
    ):
        result = result[1:-1].strip()
    if result.startswith("`") and result.endswith("`"):
        result = result[1:-1].strip()

    return result or base_prompt


async def _maybe_handle_image_locally(username: str, message: str) -> Optional[str]:
    """
    Sadece Bela (force_local) veya LOCAL_CHAT aksiyonlarÄ±nda,
    Groq'a gitmeden image isteÄŸini yakalayÄ±p,
    prompt'u Bela ile detaylandÄ±rÄ±p Ä°ngilizceye Ã§evirir ve resmi Ã¼retir.
    """
    try:
        decision = run_decider_stub(message)
    except Exception as e:
        logger.error(f"[LOCAL_IMAGE] run_decider_stub hata: {e}")
        decision = {}

    if decision.get("action") != "IMAGE":
        return None

    image_info = decision.get("image") or {}
    base_prompt = image_info.get("prompt") or message

    detailed_prompt = await _build_image_prompt_with_bela(username, base_prompt)

    logger.info(f"[LOCAL_IMAGE] user={username} prompt={detailed_prompt!r}")

    reply = generate_image_sync(username, detailed_prompt)
    return reply


async def process_chat_message(
    username: str,
    message: str,
    force_local: bool = False,
    conversation_id: Optional[str] = None,
) -> str:
    user = get_user_by_username(username)

     # 1) "Sadece Bela" modu â†’ DECIDER bypass
    if force_local:
        if not user:
            return "KullanÄ±cÄ± bilgisine ulaÅŸÄ±lamadÄ±, tekrar giriÅŸ yapmayÄ± dene."

        if not getattr(user, "can_use_local_chat", False):
            return (
                "Bu hesap iÃ§in yerel/sansÃ¼rsÃ¼z model devreye alÄ±nmamÄ±ÅŸ. "
                "Admin panelinden yetki verilmesi gerekiyor."
            )

        if getattr(user, "censorship_level", 1) != 0:
            return (
                "HesabÄ±n sansÃ¼rsÃ¼z (0) modda olmadÄ±ÄŸÄ± iÃ§in 'sadece Bela' modunu "
                "kullanamazsÄ±n."
            )

        # 1.a) Ã–nce bu mesaj bir resim isteÄŸi mi, onu kontrol et
        image_reply = await _maybe_handle_image_locally(username, message)
        if image_reply is not None:
            return image_reply

        # 1.b) DeÄŸilse normal Bela metin cevabÄ±
        logger.info("[FORCE_LOCAL] KullanÄ±cÄ± sadece Bela modunu aktif etmiÅŸ, DECIDER bypass.")
        analysis = {"forced_mode": "LOCAL_ONLY"}
        local_reply = await run_local_chat(username, message, analysis=analysis)
        return "[BELA] " + local_reply


    # 2) Normal mod: DECIDER ile devam
    decision = run_decider(message)
    action = decision.get("action")
    analysis = decision.get("analysis", {})

    logger.info(f"[DECIDER] user={username} action={action} analysis={analysis}")

    # ----------------------------------------------------
    # GROQ_REPLY â†’ Groq + baÄŸlam (geÃ§miÅŸ + hafÄ±za + RAG)
    # ----------------------------------------------------
    if action == "GROQ_REPLY":
        context_blocks = []

        # a) Sohbet geÃ§miÅŸi (conversation_id geldiyse)
        if conversation_id:
            try:
                conv_ctx = get_recent_context(username, conversation_id)
            except Exception as e:
                logger.error("get_recent_context hata: %s", e)
                conv_ctx = ""
            if conv_ctx:
                context_blocks.append("### SOHBET GEÃ‡MÄ°ÅÄ° ###\n" + conv_ctx)

        # b) KiÅŸisel hafÄ±za
        try:
            mem_items = search_memories(username, message)
        except Exception as e:
            logger.error("search_memories hata: %s", e)
            mem_items = []
        if mem_items:
            mem_text = "\n".join(f"- {m.text}" for m in mem_items)
            context_blocks.append("### KULLANICI HAFIZASI ###\n" + mem_text)

        # c) RAG (user + global + conversation)
        try:
            rag_docs = search_documents(
                message,
                owner=username,
                scopes=["user", "global", "conversation"],
            )
        except Exception as e:
            logger.error("search_documents hata: %s", e)
            rag_docs = []
        if rag_docs:
            rag_text = "\n".join(f"- {d.text}" for d in rag_docs)
            context_blocks.append("### RAG BELGELERÄ° ###\n" + rag_text)

        context_text = "\n\n".join(context_blocks) if context_blocks else None

        # Groq cevabÄ±nÄ± al
        groq_answer = await generate_answer(
            message,
            analysis=analysis,
            context=context_text,
        )

        logger.info(f"[GROQ_REPLY] Groq cevabÄ± (ilk 200): {groq_answer[:200]!r}")

        # Groq gÃ¼venlik/etik nedeniyle kaÃ§Ä±ndÄ±ysa â†’ Bela fallback
        user = get_user_by_username(username)
        can_local = bool(user and getattr(user, "can_use_local_chat", False))
        level = getattr(user, "censorship_level", 0) if user else 0

        from router.groq_answerer import groq_failed_safety

        if groq_failed_safety(groq_answer) and can_local and level <= 1:
            logger.info("[FAILOVER] Groq cevabÄ± gÃ¼venlik/etik reddi gibi gÃ¶rÃ¼nÃ¼yor, Bela'ya aktarÄ±yoruz.")
            local_reply = await run_local_chat(username, message, analysis=analysis)
            return "[BELA] " + local_reply
        # ------------------------------------------------
        # Otomatik kiÅŸisel hafÄ±za kaydÄ± (Groq kararÄ± ile)
        # ------------------------------------------------
        try:
            mem_decision = await decide_memory_storage(message, groq_answer)
            if mem_decision.get("store"):
                mem_text = (
                    mem_decision.get("memory")
                    or mem_decision.get("text")
                    or ""
                )
                mem_text = mem_text.strip()
                if mem_text:
                    importance = float(mem_decision.get("importance", 0.5))
                    add_memory(
                        username,
                        mem_text,
                        importance=importance,
                        tags=["auto"],
                    )
                    logger.info("[MEMORY] Otomatik hafÄ±za kaydedildi: %s", mem_text)
        except Exception as e:
            logger.error("Otomatik memory kaydÄ± sÄ±rasÄ±nda hata: %s", e)
                # -----------------------------------------------
        # UZUN SOHBET Ã–ZETÄ° â†’ RAG (conversation scope)
        # -----------------------------------------------
        try:
            # 1. Sohbet mesajlarÄ±nÄ± al
            msgs = get_recent_context(username, conversation_id, max_messages=999, max_chars=20000)

            # 2. EÄŸer sohbet 4000+ karaktere ulaÅŸmÄ±ÅŸsa Ã¶zetlenebilir
            if msgs and len(msgs) > 4000:
                summary = await summarize_conversation_for_rag(msgs)
                if summary:
                    add_document(
                        text=summary,
                        scope="conversation",
                        owner=username,
                        metadata={"conv_id": conversation_id},
                    )
                    logger.info("[RAG] Uzun sohbet Ã¶zeti RAG'e eklendi.")
        except Exception as e:
            logger.error(f"Sohbet Ã¶zeti oluÅŸturulamadÄ±: {e}")

        return "[GROQ] " + groq_answer

    # ----------------------------------------------------
    # IMAGE â†’ Flux / Forge ile gÃ¶rsel Ã¼ret
    # ----------------------------------------------------
    if action == "IMAGE":
        image_info = decision.get("image", {})
        prompt = image_info.get("prompt") or message  # fallback: karar verici bozulursa

        logger.info(f"[IMAGE] user={username} prompt={prompt!r}")

        reply = generate_image_sync(username, prompt)
        
        # --- YENÄ° EKLENEN KISIM: Prompt'u cevaba ekle ---
        # reply ÅŸuna benziyor: "[IMAGE] ... IMAGE_PATH: /images/x.png"
        # Sonuna PROMPT ekliyoruz.
        return f"{reply} PROMPT: {prompt}"


    # ----------------------------------------------------
    # INTERNET â†’ Web aramasÄ± + Groq ANSWERER (zaten context kullanÄ±yor)
    # ----------------------------------------------------
    if action == "INTERNET":
        text = await handle_internet_action(decision, username, message)
        return "[NET] " + text

    # ----------------------------------------------------
    # LOCAL_CHAT â†’ KullanÄ±cÄ± tercihiyle doÄŸrudan Bela
    # ----------------------------------------------------
    if action == "LOCAL_CHAT":
    # ğŸ”¹ Ã–nce resim isteÄŸi mi, onu kontrol et
        image_reply = await _maybe_handle_image_locally(username, message)
        if image_reply is not None:
            return image_reply

        user = get_user_by_username(username)
        if not user:
            logger.warning(f"LOCAL_CHAT: user objesi bulunamadÄ±: {username}")
            return "Seni tanÄ±yamadÄ±m gibi, lÃ¼tfen tekrar giriÅŸ yapmayÄ± dene."

        if not user.can_use_local_chat:
            return (
                "Bu hesap iÃ§in ÅŸu anda yerel/sansÃ¼rsÃ¼z modu kullanamÄ±yorsun. "
                "EÄŸer aÃ§Ä±lmasÄ±nÄ± istiyorsan yÃ¶neticiden rica edebilirsin."
            )

        if user.censorship_level >= 2:
            return (
                "HesabÄ±n iÃ§in ayarlanan sansÃ¼r seviyesi nedeniyle yerel/sansÃ¼rsÃ¼z modu kullanamÄ±yorsun. "
                "Bu, senin gÃ¼venliÄŸin iÃ§in bÃ¶yle ayarlanmÄ±ÅŸ olabilir."
            )

        local_reply = await run_local_chat(username, message, analysis=analysis)
        return "[BELA] " + local_reply


    return "HazÄ±rlÄ±k aÅŸamasÄ±ndayÄ±z, aksiyon tÃ¼rÃ¼nÃ¼ tanÄ±yamadÄ±m ama sistem Ã§alÄ±ÅŸÄ±yor ğŸ™‚"
